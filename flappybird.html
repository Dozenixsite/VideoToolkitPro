<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>GameHub • Flappy Bird</title>
  <style>
    /* ===== Base / Reset ===== */
    :root {
      --bg: #0b0f14;           /* GameHub dark background */
      --panel: #111827;        /* modal card */
      --muted: #94a3b8;        /* slate-400 */
      --text: #e5e7eb;         /* gray-200 */
      --accent: #4cc9f0;       /* requested accent */
      --accent-600: #34add6;
      --danger: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      overflow: hidden;             /* No scrollbars (desktop + mobile) */
      background: radial-gradient(1200px 800px at 70% 20%, #121826 0%, var(--bg) 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: none;           /* Disable panning/zooming gestures to avoid scroll */
    }
    /* ===== Layout ===== */
    .game-root {
      position: fixed; inset: 0;   /* Fullscreen */
      display: grid;
      place-items: center;
    }
    /* Canvas fills screen and keeps crisp rendering on DPR devices */
    canvas#game {
      width: 100vw;  /* Responsive: matches requirement */
      height: 100vh; /* Responsive: matches requirement */
      display: block;
      background: linear-gradient(#0c1320, #0b0f14 60%);
    }
    /* ===== HUD / Score ===== */
    .hud {
      position: fixed; inset-inline: 0; top: 10px;
      display: flex; justify-content: center; pointer-events: none;
      text-shadow: 0 2px 14px rgba(0,0,0,.6);
    }
    .score {
      font-weight: 800; letter-spacing: 1px;
      font-size: clamp(24px, 4vw, 56px);
      color: #fff;
      mix-blend-mode: screen;
    }
    .highscore {
      position: fixed; right: 16px; top: 14px; pointer-events: none;
      font-size: 14px; color: var(--muted);
    }
    /* ===== Modal ===== */
    .modal {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(0,0,0,.55); backdrop-filter: blur(2px);
      opacity: 0; visibility: hidden; transition: .25s ease;
    }
    .modal.show { opacity: 1; visibility: visible; }
    .modal-card {
      width: min(92vw, 460px);
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 22px 22px 18px;
      text-align: center;
    }
    .modal h2 {
      margin: 4px 0 2px; font-size: 24px; font-weight: 800;
    }
    .modal p { margin: 8px 0 0; color: var(--muted); }
    .stat {
      margin: 14px auto 18px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
    }
    .stat .k {
      background: rgba(255,255,255,.03);
      padding: 12px; border-radius: 14px; border: 1px solid rgba(255,255,255,.06);
    }
    .stat .k .label { font-size: 12px; color: var(--muted); }
    .stat .k .val { font-size: 22px; font-weight: 800; margin-top: 4px; }
    .btn {
      cursor: pointer;
      display: inline-flex; align-items: center; justify-content: center;
      gap: 8px; padding: 12px 18px; border-radius: 14px;
      font-weight: 700; letter-spacing: .3px;
      border: 0; color: #0b0f14; background: var(--accent);
      box-shadow: 0 6px 20px rgba(76,201,240,.25), inset 0 0 0 1px rgba(255,255,255,.25);
      transition: transform .06s ease, filter .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px) scale(.99); }
    .hint {
      position: fixed; left: 16px; bottom: 16px; font-size: 12px; color: var(--muted);
      background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.06);
      padding: 8px 10px; border-radius: 10px;
    }
  </style>
</head>
<body>
  <div class="game-root" id="root">
    <canvas id="game" aria-label="Flappy Bird Clone Canvas" role="img"></canvas>
    <div class="hud"><div class="score" id="score">0</div></div>
    <div class="highscore" id="highscore">Best: 0</div>
    <div class="hint">Tap / Click / Space to flap</div>
  </div>
  <!-- Game Over Modal -->
  <div class="modal" id="gameOverModal" aria-modal="true" role="dialog">
    <div class="modal-card">
      <h2>Game Over</h2>
      <div class="stat">
        <div class="k"><div class="label">Score</div><div class="val" id="finalScore">0</div></div>
        <div class="k"><div class="label">High Score</div><div class="val" id="bestScore">0</div></div>
      </div>
      <button class="btn" id="playAgainBtn" type="button">▶ Play Again</button>
      <p style="margin-top:12px">Tap / Click / Press Space to flap</p>
    </div>
  </div>
  <script>
  // ===========================
  // Flappy Bird – GameHub Clone
  // ===========================
  // Architecture overview
  // - Responsive canvas that maps to a stable "world" measured in virtual units
  // - Entities: Bird (circle), PipePair (two rects with a gap)
  // - Systems: Physics (gravity & flap), Spawner (pipes), Collision, Scoring, Difficulty ramp
  // - Inputs: Pointer (tap/click) + Keyboard (Space). Mobile scroll prevented.
  // - Render: requestAnimationFrame (time-based), crisp on high-DPR displays
  (function() {
    'use strict';
    // ====== DOM refs ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('highscore');
    const modal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
    const bestScoreEl = document.getElementById('bestScore');
    const playAgainBtn = document.getElementById('playAgainBtn');
    // ====== Local Storage (High Score) ======
    const HS_KEY = 'flappy_highscore_v1';
    const getHighScore = () => Number(localStorage.getItem(HS_KEY) || 0);
    const setHighScore = (v) => localStorage.setItem(HS_KEY, String(v));
    // ====== World units (responsive) ======
    // We keep physics consistent by simulating in virtual units.
    const WORLD = {
      h: 100, // virtual height units (constant)
      w: 177, // virtual width is updated in resize() based on aspect
      // scaling factor from world units -> pixels is derived each frame
    };
    // ====== Game state ======
    const GameState = {
      RUNNING: 0,
      GAME_OVER: 1,
      READY: 2, // initial state before first flap
    };
    // ====== Bird entity ======
    class Bird {
      constructor() {
        this.reset();
      }
      reset() {
        this.r = 4.5;                  // radius in world units
        this.x = WORLD.w * 0.25;       // fixed x position
        this.y = WORLD.h * 0.5;        // start mid
        this.vy = 0;                   // vertical velocity (units/s)
        this.gravity = 130;            // units/s^2 (tuned for world scale)
        this.flapImpulse = -48;        // instant vy change (negative -> up)
        this.alive = true;
        this.rot = 0;                  // for a bit of tilt
      }
      flap() {
        if (!this.alive) return;
        this.vy = this.flapImpulse;
      }
      update(dt) {
        this.vy += this.gravity * dt;     // apply gravity
        this.y += this.vy * dt;           // integrate position
        // Tilt: up when moving up, down when falling
        const targetRot = Math.max(-0.8, Math.min(1.3, this.vy / 90));
        this.rot += (targetRot - this.rot) * Math.min(1, dt * 12);
      }
      draw(ctx, scale) {
        ctx.save();
        ctx.translate(this.x * scale, this.y * scale);
        ctx.rotate(this.rot);
        // Bird body (simple circle) with subtle highlight
        const r = this.r * scale;
        const grd = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.2, 0, 0, r);
        grd.addColorStop(0, '#fffb');
        grd.addColorStop(1, '#f5b942');
        ctx.fillStyle = grd; // warm yellow/orange body
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
        // Eye
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(r*0.25, -r*0.2, r*0.16, 0, Math.PI*2); ctx.fill();
        // Beak (small triangle)
        ctx.fillStyle = '#f59f00';
        ctx.beginPath();
        ctx.moveTo(r*0.9, 0); ctx.lineTo(r*1.3, -r*0.15); ctx.lineTo(r*1.3, r*0.15); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      intersectsRect(rx, ry, rw, rh) {
        // Circle-rectangle collision (bird circle vs pipe rectangle) in world units
        // Clamp point from circle center to rect
        const cx = this.x, cy = this.y, r = this.r;
        const closestX = Math.max(rx, Math.min(cx, rx + rw));
        const closestY = Math.max(ry, Math.min(cy, ry + rh));
        const dx = cx - closestX, dy = cy - closestY;
        return (dx*dx + dy*dy) <= r*r;
      }
    }
    // ====== Pipe pair (top + bottom) ======
    class PipePair {
      constructor(x, gapY, gapH, w, speed) {
        this.x = x;           // left x of pipe (world units)
        this.gapY = gapY;     // center of the gap
        this.gapH = gapH;     // gap height
        this.w = w;           // pipe width
        this.speed = speed;   // horizontal speed (units/s)
        this.scored = false;  // has the player scored on this pair?
      }
      update(dt, speed) {
        // Speed can ramp up over time; use latest
        this.x -= speed * dt;
      }
      isOffscreen() { return (this.x + this.w) < -5; }
      draw(ctx, scale, worldH) {
        const px = this.x * scale;
        const pw = this.w * scale;
        const gapTop = (this.gapY - this.gapH/2) * scale;
        const gapBot = (this.gapY + this.gapH/2) * scale;
        ctx.fillStyle = '#22c55e'; // green pipes
        // Top pipe (from 0 to gapTop)
        ctx.fillRect(px, 0, pw, Math.max(0, gapTop));
        // Bottom pipe (from gapBot to bottom)
        ctx.fillRect(px, gapBot, pw, (worldH*scale - gapBot));
        // Pipe lips for a bit of style
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(px - 2, Math.max(0, gapTop - 12), pw + 4, 12);
        ctx.fillRect(px - 2, gapBot, pw + 4, 12);
      }
    }
    // ====== Game controller ======
    const Game = {
      state: GameState.READY,
      pipes: [],
      bird: new Bird(),
      score: 0,
      best: getHighScore(),
      speedBase: 32,           // base pipe speed (units/s)
      speedMax: 32,            // cap - keep constant
      spawnBase: 1.35,         // base spawn interval (s) - keep constant
      spawnMin: 1.35,          // min spawn interval (s) - keep constant
      pipeW: 12,
      gapHBase: 30,            // gap height - keep constant
      gapHMin: 30,             // min gap height - keep constant
      elapsed: 0,
      spawnTimer: 0,
      reset() {
        this.pipes.length = 0;
        this.bird.reset();
        this.score = 0;
        this.elapsed = 0;
        this.spawnTimer = 0;
        this.state = GameState.READY;
        updateHUD();
        hideModal();
      },
      startIfReady() {
        if (this.state === GameState.READY) this.state = GameState.RUNNING;
      },
      currentSpeed() {
        // Keep speed constant
        return this.speedBase;
      },
      currentGap() {
        // Keep gap constant
        return this.gapHBase;
      },
      currentSpawnInterval() {
        // Keep spawn interval constant
        return this.spawnBase;
      },
      update(dt) {
        if (this.state !== GameState.RUNNING) return;
        this.elapsed += dt;
        // Update bird
        this.bird.update(dt);
        // Spawn pipes at interval, with random gapY
        this.spawnTimer += dt;
        const needSpawn = this.spawnTimer >= this.currentSpawnInterval();
        if (needSpawn) {
          this.spawnTimer = 0;
          const margin = 18; // keep gap fully on-screen
          const gapH = this.currentGap();
          const gapY = rand(margin + gapH/2, WORLD.h - margin - gapH/2);
          const startX = WORLD.w + 8; // start just off the right edge
          this.pipes.push(new PipePair(startX, gapY, gapH, this.pipeW, this.currentSpeed()));
        }
        // Update pipes & remove offscreen
        const speed = this.currentSpeed();
        for (let i = this.pipes.length - 1; i >= 0; i--) {
          const p = this.pipes[i];
          p.update(dt, speed);
          if (p.isOffscreen()) this.pipes.splice(i, 1);
        }
        // Scoring: when bird passes pipe center
        for (const p of this.pipes) {
          const passed = (p.x + p.w) < this.bird.x && !p.scored;
          if (passed) {
            p.scored = true;
            this.score += 1;
            updateHUD();
          }
        }
        // Collisions: with pipes
        for (const p of this.pipes) {
          const topRect = { x: p.x, y: 0, w: p.w, h: p.gapY - p.gapH/2 };
          const botRect = { x: p.x, y: p.gapY + p.gapH/2, w: p.w, h: WORLD.h - (p.gapY + p.gapH/2) };
          if (this.bird.intersectsRect(topRect.x, topRect.y, topRect.w, topRect.h) ||
              this.bird.intersectsRect(botRect.x, botRect.y, botRect.w, botRect.h)) {
            this.gameOver();
            return;
          }
        }
        // Collisions: world bounds (ceiling/ground)
        if (this.bird.y - this.bird.r <= 0 || this.bird.y + this.bird.r >= WORLD.h) {
          this.gameOver();
          return;
        }
      },
      draw() {
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Background subtle stars
        drawStarfield();
        // Draw pipes
        for (const p of this.pipes) p.draw(ctx, scale, WORLD.h);
        // Draw bird
        this.bird.draw(ctx, scale);
        // Ground line (visual reference)
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, scale * 0.4);
        ctx.beginPath();
        ctx.moveTo(0, (WORLD.h - 1) * scale); ctx.lineTo(WORLD.w * scale, (WORLD.h - 1) * scale); ctx.stroke();
        ctx.globalAlpha = 1;
        // Ready hint pulse
        if (this.state === GameState.READY) {
          ctx.save();
          ctx.translate((WORLD.w * 0.5) * scale, (WORLD.h * 0.4) * scale);
          ctx.textAlign = 'center';
          ctx.font = `${Math.floor(8*scale)}px sans-serif`;
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          ctx.fillText('Tap / Click / Space to start', 0, 0);
          ctx.restore();
        }
      },
      gameOver() {
        this.state = GameState.GAME_OVER;
        this.bird.alive = false;
        // Persist high score
        if (this.score > this.best) {
          this.best = this.score;
          setHighScore(this.best);
        }
        // Update modal UI
        finalScoreEl.textContent = String(this.score);
        bestScoreEl.textContent = String(this.best);
        showModal();
      }
    };
    // ====== Utility ======
    function rand(min, max) { return Math.random() * (max - min) + min; }
    // ====== HUD updates ======
    function updateHUD() {
      scoreEl.textContent = String(Game.score);
      highEl.textContent = `Best: ${Game.best}`;
    }
    // ====== Modal control ======
    function showModal() { modal.classList.add('show'); }
    function hideModal() { modal.classList.remove('show'); }
    // ====== Starfield backdrop (lightweight) ======
    const stars = Array.from({ length: 80 }, () => ({
      x: Math.random(), y: Math.random(), r: Math.random()*1.2 + 0.2
    }));
    function drawStarfield() {
      const w = canvas.width, h = canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.7;
      for (const s of stars) {
        const px = s.x * w, py = s.y * h;
        ctx.beginPath();
        ctx.arc(px, py, s.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.fill();
      }
      ctx.restore();
    }
    // ====== Resize / DPR handling ======
    let scale = 1; // world unit -> pixels
    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // clamp DPR for perf
      const cssW = Math.max(1, Math.floor(window.innerWidth));
      const cssH = Math.max(1, Math.floor(window.innerHeight));
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      // Recompute world width based on aspect so physics stay stable
      WORLD.w = WORLD.h * (canvas.width / canvas.height);
      scale = canvas.height / WORLD.h; // pixels per world unit (based on height)
    }
    window.addEventListener('resize', resizeCanvas, { passive: true });
    window.addEventListener('orientationchange', () => {
      // iOS sometimes needs a small delay
      setTimeout(resizeCanvas, 60);
    }, { passive: true });
    // ====== Input handling ======
    function onFlap() {
      Game.startIfReady();
      if (Game.state === GameState.RUNNING) Game.bird.flap();
    }
    // Keyboard (Space)
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); onFlap(); }
      if (e.code === 'Enter' && Game.state === GameState.GAME_OVER) restart();
    });
    // Pointer / Touch (tap or click anywhere)
    // Using pointer events covers mouse + touch with minimal delay
    window.addEventListener('pointerdown', (e) => {
      // Prevent potential double-tap zoom / scrolling
      e.preventDefault();
      onFlap();
    }, { passive: false });
    // Block scroll during drags/moves while playing
    window.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
    // Play again button
    playAgainBtn.addEventListener('click', () => restart());
    function restart() {
      hideModal();
      Game.reset();
    }
    // ====== Main loop ======
    let lastTime = 0;
    function loop(ts) {
      if (!lastTime) lastTime = ts; // first frame
      const dt = Math.min(0.033, (ts - lastTime) / 1000); // cap delta to avoid jumps
      lastTime = ts;
      Game.update(dt);
      Game.draw();
      requestAnimationFrame(loop);
    }
    // ====== Boot ======
    function init() {
      Game.best = getHighScore();
      updateHUD();
      resizeCanvas();
      Game.reset();
      requestAnimationFrame(loop);
    }
    // Run after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    // ====== Accessibility / Tab focus hints ======
    window.addEventListener('blur', () => {
      // Optional: could pause here, but acceptance criteria doesn't require pause
      // Keeping it running is simpler; users can restart after a death.
    });
  })();
  </script>
</body>
</html>
