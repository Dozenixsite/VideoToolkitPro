<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - GameHub</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #8a2be2;
            --secondary: #4b0082;
            --dark: #121212;
            --darker: #0a0a0a;
            --light: #f5f5f5;
            --gray: #2d2d2d;
            --card-bg: #1e1e1e;
            --hover: #2a2a2a;
            --white: #f0d9b5;
            --black: #b58863;
            --highlight: #aec6cf;
            --check: #ff6b6b;
            --border: #3a3a3a;
        }

        body {
            background: linear-gradient(135deg, var(--darker), var(--dark));
            color: var(--light);
            min-height: 100vh;
            padding-bottom: 40px;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header Styles */
        header {
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary);
            text-decoration: none;
        }

        .logo i {
            color: #ff6b6b;
        }

        nav a {
            color: var(--light);
            text-decoration: none;
            font-weight: 500;
            padding: 8px 15px;
            border-radius: 30px;
            transition: all 0.3s;
        }

        nav a:hover {
            background: rgba(138, 43, 226, 0.2);
            color: var(--primary);
        }

        /* Game Section */
        .game-section {
            margin: 40px 0;
        }

        .section-title {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--primary);
        }

        .game-rules {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .game-rules h3 {
            margin-bottom: 15px;
            color: var(--primary);
        }

        .game-rules ul {
            padding-left: 20px;
        }

        .game-rules li {
            margin-bottom: 10px;
            color: #b0b0b0;
        }

        /* Game Container */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            background: var(--card-bg);
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .status {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .status span {
            color: var(--primary);
        }

        /* Chess Board Container */
        .chess-board-container {
            width: min(500px, 90vw);
            aspect-ratio: 1/1;
            position: relative;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Square styling with clean borders */
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 4vw, 3rem);
            cursor: pointer;
            position: relative;
            background-color: var(--white);
        }

        /* Dark squares */
        .square:nth-child(8n+2),
        .square:nth-child(8n+4),
        .square:nth-child(8n+6),
        .square:nth-child(8n+8),
        .square:nth-child(8n+9),
        .square:nth-child(8n+11),
        .square:nth-child(8n+13),
        .square:nth-child(8n+15),
        .square:nth-child(8n+18),
        .square:nth-child(8n+20),
        .square:nth-child(8n+22),
        .square:nth-child(8n+24),
        .square:nth-child(8n+25),
        .square:nth-child(8n+27),
        .square:nth-child(8n+29),
        .square:nth-child(8n+31),
        .square:nth-child(8n+34),
        .square:nth-child(8n+36),
        .square:nth-child(8n+38),
        .square:nth-child(8n+40),
        .square:nth-child(8n+41),
        .square:nth-child(8n+43),
        .square:nth-child(8n+45),
        .square:nth-child(8n+47),
        .square:nth-child(8n+50),
        .square:nth-child(8n+52),
        .square:nth-child(8n+54),
        .square:nth-child(8n+56),
        .square:nth-child(8n+57),
        .square:nth-child(8n+59),
        .square:nth-child(8n+61),
        .square:nth-child(8n+63) {
            background-color: var(--black);
        }

        /* Border implementation to avoid gaps */
        .square:not(:nth-child(8n+8)) {
            border-right: 1px solid var(--border);
        }

        .square:nth-child(n+9) {
            border-top: 1px solid var(--border);
        }

        /* Outer borders */
        .chess-board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid var(--border);
            pointer-events: none;
        }

        .square.selected {
            background-color: var(--highlight);
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 128, 0, 0.5);
            border-radius: 50%;
        }

        .square.valid-capture {
            box-shadow: inset 0 0 0 3px rgba(255, 0, 0, 0.5);
        }

        .square.check {
            background-color: var(--check);
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            background: linear-gradient(90deg, var(--primary), #ff6b6b);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.4);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: var(--primary);
        }

        .modal p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #b0b0b0;
        }

        /* Captured Pieces */
        .captured-pieces {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-top: 10px;
        }

        .captured-white, .captured-black {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 10px 15px;
            min-height: 40px;
            min-width: 100px;
        }

        .captured-white {
            border: 1px solid var(--white);
        }

        .captured-black {
            border: 1px solid var(--black);
        }

        .captured-title {
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #aaa;
        }

        .captured-icons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .captured-icon {
            font-size: 1.2rem;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .game-info {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .captured-pieces {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container header-content">
            <a href="index.html" class="logo">
                <i class="fas fa-gamepad"></i>
                <span>GameHub</span>
            </a>
            <nav>
                <a href="index.html"><i class="fas fa-home"></i> Back to Home</a>
            </nav>
        </div>
    </header>

    <!-- Game Section -->
    <section class="game-section">
        <div class="container">
            <h2 class="section-title">Chess</h2>
            
            <div class="game-rules">
                <h3>How to Play</h3>
                <ul>
                    <li>You play as White, the computer plays as Black</li>
                    <li>Click on a piece to select it, then click on a valid square to move</li>
                    <li>Checkmate the opponent's king to win the game</li>
                    <li>If neither player can checkmate, the game ends in a draw</li>
                    <li>Special moves: Castling, En Passant, and Pawn Promotion</li>
                </ul>
            </div>
            
            <div class="game-container">
                <div class="game-info">
                    <div class="status">Status: <span id="status">Your turn (White)</span></div>
                    <div class="status">Turn: <span id="turn">1</span></div>
                </div>
                
                <div class="captured-pieces">
                    <div class="captured-white">
                        <div class="captured-title">Captured by White</div>
                        <div class="captured-icons" id="capturedWhite"></div>
                    </div>
                    <div class="captured-black">
                        <div class="captured-title">Captured by Black</div>
                        <div class="captured-icons" id="capturedBlack"></div>
                    </div>
                </div>
                
                <div class="chess-board-container">
                    <div class="chess-board" id="chessBoard">
                        <!-- Board will be generated by JavaScript -->
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn" id="newGameBtn">New Game</button>
                    <button class="btn" id="undoBtn">Undo Move</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameResult">Game Over</h2>
            <p id="resultMessage">Checkmate! You win!</p>
            <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        // Chess piece symbols (Unicode)
        const pieces = {
            'white-king': '♔',
            'white-queen': '♕',
            'white-rook': '♖',
            'white-bishop': '♗',
            'white-knight': '♘',
            'white-pawn': '♙',
            'black-king': '♚',
            'black-queen': '♛',
            'black-rook': '♜',
            'black-bishop': '♝',
            'black-knight': '♞',
            'black-pawn': '♟'
        };

        // Game state
        let board = [];
        let currentPlayer = 'white';
        let selectedPiece = null;
        let validMoves = [];
        let moveHistory = [];
        let turnCount = 1;
        let capturedPieces = { white: [], black: [] };
        let kings = { white: null, black: null };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null;

        // DOM elements
        const chessBoard = document.getElementById('chessBoard');
        const statusDisplay = document.getElementById('status');
        const turnDisplay = document.getElementById('turn');
        const newGameBtn = document.getElementById('newGameBtn');
        const undoBtn = document.getElementById('undoBtn');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameResult = document.getElementById('gameResult');
        const resultMessage = document.getElementById('resultMessage');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const capturedWhite = document.getElementById('capturedWhite');
        const capturedBlack = document.getElementById('capturedBlack');

        // Initialize the board
        function initBoard() {
            // Create 8x8 board
            board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pawns
            for (let i = 0; i < 8; i++) {
                board[1][i] = 'black-pawn';
                board[6][i] = 'white-pawn';
            }
            
            // Set up other pieces
            board[0][0] = 'black-rook';
            board[0][1] = 'black-knight';
            board[0][2] = 'black-bishop';
            board[0][3] = 'black-queen';
            board[0][4] = 'black-king';
            board[0][5] = 'black-bishop';
            board[0][6] = 'black-knight';
            board[0][7] = 'black-rook';
            
            board[7][0] = 'white-rook';
            board[7][1] = 'white-knight';
            board[7][2] = 'white-bishop';
            board[7][3] = 'white-queen';
            board[7][4] = 'white-king';
            board[7][5] = 'white-bishop';
            board[7][6] = 'white-knight';
            board[7][7] = 'white-rook';
            
            // Set king positions
            kings.white = { row: 7, col: 4 };
            kings.black = { row: 0, col: 4 };
            
            // Reset game state
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            moveHistory = [];
            turnCount = 1;
            capturedPieces = { white: [], black: [] };
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            
            updateStatus();
            renderBoard();
            updateCapturedPieces();
        }

        // Render the board
        function renderBoard() {
            chessBoard.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Add piece if exists
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece];
                    }
                    
                    // Highlight selected piece
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Highlight valid moves
                    const isValidMove = validMoves.some(move => 
                        move.row === row && move.col === col
                    );
                    
                    if (isValidMove) {
                        const targetPiece = board[row][col];
                        if (targetPiece) {
                            square.classList.add('valid-capture');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }
                    
                    // Highlight king in check
                    if (kings[currentPlayer] && 
                        kings[currentPlayer].row === row && 
                        kings[currentPlayer].col === col && 
                        isKingInCheck(currentPlayer)) {
                        square.classList.add('check');
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessBoard.appendChild(square);
                }
            }
        }

        // Handle square click
        function handleSquareClick(row, col) {
            // If game is over, do nothing
            if (gameOverModal.classList.contains('active')) return;
            
            const piece = board[row][col];
            
            // If a piece is already selected
            if (selectedPiece) {
                // Check if clicked on a valid move
                const isValidMove = validMoves.some(move => 
                    move.row === row && move.col === col
                );
                
                if (isValidMove) {
                    // Move the piece
                    movePiece(selectedPiece.row, selectedPiece.col, row, col);
                    return;
                }
                
                // Deselect if clicking on the same piece
                if (selectedPiece.row === row && selectedPiece.col === col) {
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard();
                    return;
                }
            }
            
            // Select a piece if it's the current player's piece
            if (piece && piece.startsWith(currentPlayer)) {
                selectedPiece = { row, col, piece };
                validMoves = calculateValidMoves(row, col, piece);
                renderBoard();
            }
        }

        // Calculate valid moves for a piece
        function calculateValidMoves(row, col, piece) {
            const [color, type] = piece.split('-');
            let moves = [];
            
            switch (type) {
                case 'pawn':
                    moves = getPawnMoves(row, col, color);
                    break;
                case 'rook':
                    moves = getRookMoves(row, col, color);
                    break;
                case 'knight':
                    moves = getKnightMoves(row, col, color);
                    break;
                case 'bishop':
                    moves = getBishopMoves(row, col, color);
                    break;
                case 'queen':
                    moves = getQueenMoves(row, col, color);
                    break;
                case 'king':
                    moves = getKingMoves(row, col, color);
                    break;
            }
            
            // Filter out moves that would leave the king in check
            return moves.filter(move => {
                // Simulate the move
                const originalPiece = board[move.row][move.col];
                board[move.row][move.col] = piece;
                board[row][col] = null;
                
                // Update king position if moving the king
                let originalKingPos = null;
                if (type === 'king') {
                    originalKingPos = {...kings[color]};
                    kings[color] = { row: move.row, col: move.col };
                }
                
                // Check if king is in check after the move
                const inCheck = isKingInCheck(color);
                
                // Restore the board
                board[row][col] = piece;
                board[move.row][move.col] = originalPiece;
                
                // Restore king position
                if (type === 'king' && originalKingPos) {
                    kings[color] = originalKingPos;
                }
                
                return !inCheck;
            });
        }

        // Pawn moves
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Move forward
            if (isValidPosition(row + direction, col) && !board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // Initial double move
                if (row === startRow && !board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
            
            // Capture diagonally
            for (let offset of [-1, 1]) {
                if (isValidPosition(row + direction, col + offset)) {
                    const targetPiece = board[row + direction][col + offset];
                    if (targetPiece && !targetPiece.startsWith(color)) {
                        moves.push({ row: row + direction, col: col + offset });
                    }
                    
                    // En passant
                    if (enPassantTarget && 
                        enPassantTarget.row === row + direction && 
                        enPassantTarget.col === col + offset) {
                        moves.push({ 
                            row: row + direction, 
                            col: col + offset, 
                            enPassant: true 
                        });
                    }
                }
            }
            
            return moves;
        }

        // Rook moves
        function getRookMoves(row, col, color) {
            const moves = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            for (let [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const targetPiece = board[newRow][newCol];
                    if (!targetPiece) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (!targetPiece.startsWith(color)) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            
            return moves;
        }

        // Knight moves
        function getKnightMoves(row, col, color) {
            const moves = [];
            const offsets = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            
            for (let [dr, dc] of offsets) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isValidPosition(newRow, newCol)) {
                    const targetPiece = board[newRow][newCol];
                    if (!targetPiece || !targetPiece.startsWith(color)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return moves;
        }

        // Bishop moves
        function getBishopMoves(row, col, color) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (let [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const targetPiece = board[newRow][newCol];
                    if (!targetPiece) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (!targetPiece.startsWith(color)) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            
            return moves;
        }

        // Queen moves (combination of rook and bishop)
        function getQueenMoves(row, col, color) {
            return [
                ...getRookMoves(row, col, color),
                ...getBishopMoves(row, col, color)
            ];
        }

        // King moves
        function getKingMoves(row, col, color) {
            const moves = [];
            
            // Regular moves
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (isValidPosition(newRow, newCol)) {
                        const targetPiece = board[newRow][newCol];
                        if (!targetPiece || !targetPiece.startsWith(color)) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }
            }
            
            // Castling
            if (canCastle(color, 'kingSide')) {
                moves.push({ row, col: col + 2, castling: 'kingSide' });
            }
            
            if (canCastle(color, 'queenSide')) {
                moves.push({ row, col: col - 2, castling: 'queenSide' });
            }
            
            return moves;
        }

        // Check if castling is possible
        function canCastle(color, side) {
            if (!castlingRights[color][side]) return false;
            
            const kingRow = color === 'white' ? 7 : 0;
            const kingCol = 4;
            
            // Check if squares are empty
            if (side === 'kingSide') {
                if (board[kingRow][5] || board[kingRow][6]) return false;
            } else {
                if (board[kingRow][1] || board[kingRow][2] || board[kingRow][3]) return false;
            }
            
            // Check if king is in check
            if (isKingInCheck(color)) return false;
            
            // Check if squares are under attack
            const squaresToCheck = side === 'kingSide' ? 
                [{row: kingRow, col: 5}, {row: kingRow, col: 6}] : 
                [{row: kingRow, col: 3}, {row: kingRow, col: 2}];
            
            for (let square of squaresToCheck) {
                if (isSquareAttacked(square.row, square.col, color)) {
                    return false;
                }
            }
            
            return true;
        }

        // Check if a square is attacked by the opponent
        function isSquareAttacked(row, col, defendingColor) {
            const attackingColor = defendingColor === 'white' ? 'black' : 'white';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.startsWith(attackingColor)) {
                        const [color, type] = piece.split('-');
                        let moves = [];
                        
                        // Get potential moves (without filtering for check)
                        switch (type) {
                            case 'pawn':
                                const direction = color === 'white' ? -1 : 1;
                                for (let offset of [-1, 1]) {
                                    if (isValidPosition(r + direction, c + offset)) {
                                        moves.push({ row: r + direction, col: c + offset });
                                    }
                                }
                                break;
                            case 'rook':
                                moves = getRookMoves(r, c, color);
                                break;
                            case 'knight':
                                moves = getKnightMoves(r, c, color);
                                break;
                            case 'bishop':
                                moves = getBishopMoves(r, c, color);
                                break;
                            case 'queen':
                                moves = getQueenMoves(r, c, color);
                                break;
                            case 'king':
                                moves = getKingMoves(r, c, color);
                                break;
                        }
                        
                        // Check if any move targets the square
                        if (moves.some(move => move.row === row && move.col === col)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Check if the king is in check
        function isKingInCheck(color) {
            const king = kings[color];
            if (!king) return false;
            return isSquareAttacked(king.row, king.col, color);
        }

        // Check if the player is in checkmate
        function isCheckmate(color) {
            if (!isKingInCheck(color)) return false;
            
            // Check if any piece can make a legal move
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.startsWith(color)) {
                        const moves = calculateValidMoves(row, col, piece);
                        if (moves.length > 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }

        // Check if the game is a stalemate
        function isStalemate(color) {
            if (isKingInCheck(color)) return false;
            
            // Check if any piece can make a legal move
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.startsWith(color)) {
                        const moves = calculateValidMoves(row, col, piece);
                        if (moves.length > 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }

        // Check if position is valid
        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // Move a piece
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const [color, type] = piece.split('-');
            
            // Save move to history
            const moveData = {
                from: { row: fromRow, col: fromCol, piece },
                to: { row: toRow, col: toCol, piece: board[toRow][toCol] },
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantTarget: enPassantTarget ? {...enPassantTarget} : null
            };
            
            // Handle special moves
            let castling = false;
            let enPassantCapture = false;
            
            // Check for castling
            const validMove = validMoves.find(move => 
                move.row === toRow && move.col === toCol
            );
            
            if (validMove && validMove.castling) {
                castling = validMove.castling;
                // Move the rook
                if (castling === 'kingSide') {
                    const rookCol = color === 'white' ? 7 : 0;
                    board[toRow][5] = board[toRow][rookCol];
                    board[toRow][rookCol] = null;
                } else {
                    const rookCol = color === 'white' ? 0 : 7;
                    board[toRow][3] = board[toRow][rookCol];
                    board[toRow][rookCol] = null;
                }
                
                // Update castling rights
                castlingRights[color].kingSide = false;
                castlingRights[color].queenSide = false;
            }
            
            // Check for en passant
            if (validMove && validMove.enPassant) {
                enPassantCapture = true;
                // Remove the captured pawn
                const capturedRow = color === 'white' ? toRow + 1 : toRow - 1;
                const capturedPiece = board[capturedRow][toCol];
                board[capturedRow][toCol] = null;
                
                // Add to captured pieces
                capturedPieces[color].push(capturedPiece);
            }
            
            // Handle pawn promotion
            let promoted = false;
            if (type === 'pawn' && (toRow === 0 || toRow === 7)) {
                board[fromRow][fromCol] = `${color}-queen`;
                promoted = true;
            }
            
            // Move the piece
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            
            // Update king position if moving the king
            if (type === 'king') {
                kings[color] = { row: toRow, col: toCol };
                // Update castling rights
                castlingRights[color].kingSide = false;
                castlingRights[color].queenSide = false;
            }
            
            // Update castling rights if moving a rook
            if (type === 'rook') {
                if (fromRow === (color === 'white' ? 7 : 0)) {
                    if (fromCol === 0) {
                        castlingRights[color].queenSide = false;
                    } else if (fromCol === 7) {
                        castlingRights[color].kingSide = false;
                    }
                }
            }
            
            // Set en passant target for double pawn moves
            enPassantTarget = null;
            if (type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                const targetRow = color === 'white' ? toRow + 1 : toRow - 1;
                enPassantTarget = { row: targetRow, col: toCol };
            }
            
            // Capture piece if exists
            if (board[toRow][toCol] && !castling && !enPassantCapture && !promoted) {
                const capturedPiece = board[toRow][toCol];
                if (capturedPiece !== piece) {
                    capturedPieces[color].push(capturedPiece);
                }
            }
            
            // Save move to history
            moveData.promoted = promoted;
            moveData.castling = castling;
            moveData.enPassantCapture = enPassantCapture;
            moveHistory.push(moveData);
            
            // Switch player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Update turn count for white moves
            if (currentPlayer === 'white') {
                turnCount++;
                turnDisplay.textContent = turnCount;
            }
            
            // Reset selection
            selectedPiece = null;
            validMoves = [];
            
            // Update status
            updateStatus();
            
            // Render updated board
            renderBoard();
            updateCapturedPieces();
            
            // Check for game end
            if (isCheckmate(currentPlayer)) {
                endGame(currentPlayer === 'white' ? 'black' : 'white');
            } else if (isStalemate(currentPlayer)) {
                endGame('draw');
            } else if (currentPlayer === 'black') {
                // Computer makes a move after a short delay
                setTimeout(makeComputerMove, 800);
            }
        }

        // Computer makes a move (simplified)
        function makeComputerMove() {
            // Find all black pieces with valid moves
            const blackPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.startsWith('black')) {
                        const moves = calculateValidMoves(row, col, piece);
                        if (moves.length > 0) {
                            blackPieces.push({ row, col, piece, moves });
                        }
                    }
                }
            }
            
            if (blackPieces.length === 0) {
                // No valid moves - check for checkmate or stalemate
                if (isCheckmate('black')) {
                    endGame('white');
                } else {
                    endGame('draw');
                }
                return;
            }
            
            // Shuffle pieces to make random selection
            for (let i = blackPieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [blackPieces[i], blackPieces[j]] = [blackPieces[j], blackPieces[i]];
            }
            
            // Try to find a valid move
            for (const piece of blackPieces) {
                if (piece.moves.length > 0) {
                    // Select a random valid move
                    const randomMove = piece.moves[Math.floor(Math.random() * piece.moves.length)];
                    selectedPiece = piece;
                    validMoves = piece.moves;
                    renderBoard();
                    
                    // Move after a short delay
                    setTimeout(() => {
                        movePiece(piece.row, piece.col, randomMove.row, randomMove.col);
                    }, 300);
                    return;
                }
            }
        }

        // Update status display
        function updateStatus() {
            if (currentPlayer === 'white') {
                statusDisplay.textContent = isKingInCheck('white') ? 
                    'Your turn (White) - Check!' : 'Your turn (White)';
            } else {
                statusDisplay.textContent = isKingInCheck('black') ? 
                    'Computer thinking... - Check!' : 'Computer thinking...';
            }
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            capturedWhite.innerHTML = '';
            capturedBlack.innerHTML = '';
            
            capturedPieces.white.forEach(piece => {
                const span = document.createElement('span');
                span.className = 'captured-icon';
                span.textContent = pieces[piece];
                capturedWhite.appendChild(span);
            });
            
            capturedPieces.black.forEach(piece => {
                const span = document.createElement('span');
                span.className = 'captured-icon';
                span.textContent = pieces[piece];
                capturedBlack.appendChild(span);
            });
        }

        // End the game
        function endGame(winner) {
            gameOverModal.classList.add('active');
            
            if (winner === 'white') {
                gameResult.textContent = 'Victory!';
                resultMessage.textContent = 'Checkmate! You win!';
            } else if (winner === 'black') {
                gameResult.textContent = 'Defeat!';
                resultMessage.textContent = 'Checkmate! Computer wins!';
            } else {
                gameResult.textContent = 'Game Over';
                resultMessage.textContent = 'Game ended in a draw!';
            }
        }

        // Undo last move
        function undoMove() {
            if (moveHistory.length === 0) return;
            
            const lastMove = moveHistory.pop();
            
            // Restore board state
            board[lastMove.from.row][lastMove.from.col] = lastMove.from.piece;
            board[lastMove.to.row][lastMove.to.col] = lastMove.to.piece;
            
            // Restore castling rights
            castlingRights = lastMove.castlingRights;
            
            // Restore en passant target
            enPassantTarget = lastMove.enPassantTarget;
            
            // Restore king positions
            const [fromColor, fromType] = lastMove.from.piece.split('-');
            if (fromType === 'king') {
                kings[fromColor] = { row: lastMove.from.row, col: lastMove.from.col };
            }
            
            // Handle special moves
            if (lastMove.castling) {
                // Move the rook back
                if (lastMove.castling === 'kingSide') {
                    const rookCol = fromColor === 'white' ? 7 : 0;
                    const rookTargetCol = fromColor === 'white' ? 5 : 4;
                    board[lastMove.to.row][rookCol] = board[lastMove.to.row][rookTargetCol];
                    board[lastMove.to.row][rookTargetCol] = null;
                } else {
                    const rookCol = fromColor === 'white' ? 0 : 7;
                    const rookTargetCol = fromColor === 'white' ? 3 : 2;
                    board[lastMove.to.row][rookCol] = board[lastMove.to.row][rookTargetCol];
                    board[lastMove.to.row][rookTargetCol] = null;
                }
            }
            
            if (lastMove.enPassantCapture) {
                // Restore the captured pawn
                const capturedRow = fromColor === 'white' ? lastMove.to.row + 1 : lastMove.to.row - 1;
                board[capturedRow][lastMove.to.col] = fromColor === 'white' ? 'black-pawn' : 'white-pawn';
            }
            
            // Remove from captured pieces if needed
            if (lastMove.to.piece) {
                capturedPieces[fromColor].pop();
            }
            
            // Switch player back
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Update turn count
            if (currentPlayer === 'black') {
                turnCount--;
                turnDisplay.textContent = turnCount;
            }
            
            // Reset selection
            selectedPiece = null;
            validMoves = [];
            
            // Update status
            updateStatus();
            
            // Render updated board
            renderBoard();
            updateCapturedPieces();
        }

        // Event listeners
        newGameBtn.addEventListener('click', initBoard);
        undoBtn.addEventListener('click', undoMove);
        playAgainBtn.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            initBoard();
        });

        // Initialize the game
        initBoard();
    </script>
</body>
</html>
